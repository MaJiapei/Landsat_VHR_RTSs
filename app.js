
// Êó∂Èó¥Â∫èÂàóÂàÜÊûêÁªÑ‰ª∂
const TimeSeriesAnalysis = {
    template: `
        <div class="time-series-container">
            <div class="points-container">
                <div class="points-header">
                <h3>Selected Points</h3>
                    <button class="clear-all-btn" @click="clearAllPoints">Clear All</button>
                </div>
                <div class="usage-hint" v-if="!hasPoints">
                    <div class="hint-icon">üìç</div>
                    <p>Click on the map to select points for analysis</p>
                </div>
                <div id="point-cards"></div>
            </div>
            <div class="plot-container">
                <div id="plot-container"></div>
            </div>
        </div>
    `,
    data() {
        return {
            pointCount: 0
        };
    },
    mounted() {
        this.initMapHandlers();
    },
    methods: {
        initMapHandlers() {
            // Á°Æ‰øùÂú∞ÂõæÂ∑≤ÂàùÂßãÂåñ
            if (!window.map) return;

            // Ê∏ÖÁ©∫Áé∞ÊúâÁÇπ
            if (window.pointsLayer) {
                window.map.removeLayer(window.pointsLayer);
            }

            // ÂàõÂª∫ÁÇπÂõæÂ±Ç
            const pointsSource = new ol.source.Vector();
            window.pointsLayer = new ol.layer.Vector({
                source: pointsSource,
                zIndex: 1000
            });
            window.map.addLayer(window.pointsLayer);

            window.points = [];
            this.pointCount = 0;
            window.nextPointIndex = 1;
            window.allColors = [
                '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
                '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf',
                '#ff9896', '#c5b0d5', '#c49c94', '#f7b6d2', '#dbdb8d',
                '#9edae5', '#393b79', '#e6550d', '#31a354', '#756bb1'
            ];

            // ‰ΩøÁî® OpenLayers ÁöÑÁÇπÂáª‰∫ã‰ª∂
            this.mapClickHandler = (evt) => this.handleMapClick(evt);
            window.map.on('singleclick', this.mapClickHandler);
        },
        async handleMapClick(e) {
            // OpenLayers ÂùêÊ†áËΩ¨Êç¢
            const coordinate = e.coordinate;
            const lonLat = ol.proj.toLonLat(coordinate);
            const lng = lonLat[0];
            const lat = lonLat[1];
            
            try {
                // Ëé∑ÂèñÊ†πÂÆû‰æãÊù•Êõ¥Êñ∞ÂÖ®Â±ÄÂä†ËΩΩÁä∂ÊÄÅ
                const root = this.$root || this;
                if (root.timeseriesLoading !== undefined) {
                    root.timeseriesLoading = true;
                }
                const response = await fetch(`${API_BASE_URL}/api/analyze`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        latitude: lat,
                        longitude: lng,
                        event_thr: 0.4,
                        min_span_steps: 1
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Analysis failed');
                }

                const data = await response.json();
                
                const pointColor = this.getNextAvailableColor();
                const pointName = this.getNextPointName();
                
                // ÂàõÂª∫ OpenLayers ÁÇπË¶ÅÁ¥†
                const feature = new ol.Feature({
                    geometry: new ol.geom.Point(ol.proj.fromLonLat([lng, lat]))
                });
                
                feature.setStyle(new ol.style.Style({
                    image: new ol.style.Circle({
                        radius: 8,
                        fill: new ol.style.Fill({ color: pointColor }),
                        stroke: new ol.style.Stroke({ color: '#fff', width: 2 })
                    })
                }));
                
                window.pointsLayer.getSource().addFeature(feature);
                
                const point = {
                    id: Date.now(),
                    name: pointName,
                    lat,
                    lng,
                    color: pointColor,
                    marker: feature,
                    data: data
                };
                
            window.points.push(point);
            this.pointCount = window.points.length;
            this.updatePointCards();
            this.updatePlot();
                
            } catch (error) {
                console.error('Analysis failed:', error);
                alert('Analysis failed: ' + error.message);
            } finally {
                // ÈáçÁΩÆÂÖ®Â±ÄÂä†ËΩΩÁä∂ÊÄÅ
                const root = this.$root || this;
                if (root.timeseriesLoading !== undefined) {
                    root.timeseriesLoading = false;
                }
            }
        },
        getNextAvailableColor() {
            const usedColors = window.points.map(p => p.color);
            return window.allColors.find(color => !usedColors.includes(color)) || window.allColors[0];
        },
        getNextPointName() {
            return `A${window.nextPointIndex++}`;
        },
        updatePointCards() {
            const container = document.getElementById('point-cards');
            container.innerHTML = '';
            
            window.points.forEach(point => {
                const card = document.createElement('div');
                card.className = 'point-card';
                
                const info = document.createElement('div');
                info.className = 'point-info';
                
                const colorDot = document.createElement('div');
                colorDot.className = 'point-color';
                colorDot.style.backgroundColor = point.color;
                
                const details = document.createElement('div');
                details.className = 'point-details';
                
                const pointName = document.createElement('div');
                pointName.className = 'point-name';
                pointName.textContent = `${point.name} (${point.lat.toFixed(6)}, ${point.lng.toFixed(6)})`;
                
                const prob = document.createElement('div');
                prob.className = 'probability';
                prob.textContent = `Probability: ${(point.data.probability * 100).toFixed(1)}%`;
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.innerHTML = '√ó';
                deleteBtn.onclick = () => this.deletePoint(point.id);
                
                details.appendChild(pointName);
                details.appendChild(prob);
                info.appendChild(colorDot);
                info.appendChild(details);
                card.appendChild(info);
                card.appendChild(deleteBtn);
                container.appendChild(card);
            });
        },
        deletePoint(id) {
            const pointIndex = window.points.findIndex(p => p.id === id);
            if (pointIndex !== -1) {
                // OpenLayers ÁßªÈô§Ë¶ÅÁ¥†
                window.pointsLayer.getSource().removeFeature(window.points[pointIndex].marker);
                window.points.splice(pointIndex, 1);
                this.pointCount = window.points.length;
                this.updatePointCards();
                this.updatePlot();
            }
        },
        clearAllPoints() {
            if (window.points && window.points.length > 0) {
                // OpenLayers Ê∏ÖÁ©∫ÊâÄÊúâË¶ÅÁ¥†
                window.pointsLayer.getSource().clear();
                window.points = [];
                this.pointCount = 0;
                this.updatePointCards();
                this.updatePlot();
            }
        },
        updatePlot() {
            const getYears = length => Array.from({length}, (_, i) => 1986 + i);
            
            const traces = window.points.map(point => ({
                x: getYears(point.data.ndvi_values.length),
                y: point.data.ndvi_values,
                type: 'scatter',
                name: point.name,
                line: { color: point.color },
                showlegend: true
            }));
            
            const shapes = window.points.reduce((acc, point) => {
                if (point.data.has_event && point.data.dip_idx !== null && point.data.tr_idx !== null) {
                    acc.push(
                        {
                            type: 'line',
                            x0: 1986 + point.data.dip_idx,
                            x1: 1986 + point.data.dip_idx,
                            y0: -2,
                            y1: 2,
                            line: {
                                color: point.color,
                                width: 2,
                                dash: 'dash'
                            }
                        },
                        {
                            type: 'line',
                            x0: 1986 + point.data.tr_idx,
                            x1: 1986 + point.data.tr_idx,
                            y0: -2,
                            y1: 2,
                            line: {
                                color: point.color,
                                width: 2,
                                dash: 'dash'
                            }
                        }
                    );
                }
                return acc;
            }, []);
            
            const layout = {
                title: 'NDVI Time Series Comparison',
                xaxis: {
                    title: 'Year',
                    tickmode: 'linear',
                    dtick: 5
                },
                yaxis: {
                    title: 'NDVI Z-Score'
                },
                shapes: shapes,
                showlegend: true,
                legend: {
                    x: 1,
                    xanchor: 'right',
                    y: 1
                }
            };
            
            Plotly.newPlot('plot-container', traces, layout);
        }
    },
    beforeUnmount() {
        // ÁßªÈô§Âú∞ÂõæÁÇπÂáª‰∫ã‰ª∂
        if (window.map && this.mapClickHandler) {
            window.map.un('singleclick', this.mapClickHandler);
        }
        
        // Ê∏ÖÁêÜÂú∞Âõæ‰∏äÁöÑÊâÄÊúâÁÇπÊ†áËÆ∞
        if (window.pointsLayer) {
            window.pointsLayer.getSource().clear();
        }
        if (window.points) {
            window.points = [];
        }
        
        // Ê∏ÖÁ©∫ÁÇπÂç°ÁâáÂÆπÂô®
        const container = document.getElementById('point-cards');
        if (container) {
            container.innerHTML = '';
        }
        
        // Ê∏ÖÁ©∫ÂõæË°®ÂÆπÂô®
        const plotContainer = document.getElementById('plot-container');
        if (plotContainer) {
            plotContainer.innerHTML = '';
        }
        
        // ÈáçÁΩÆÁÇπÁ¥¢Âºï
        window.nextPointIndex = 1;
    },
    computed: {
        hasPoints() {
            return this.pointCount > 0;
        }
    }
};

// YOLOÊ£ÄÊµãÁªÑ‰ª∂
const YoloDetection = {
    template: `
        <div class="yolo-container">
            <div class="yolo-controls">
                <div class="screenshot-hint" v-if="!screenshotImage && !detectionResult">
                    <div class="hint-icon">üì∏</div>
                    <p>Use the screenshot tool in the top-right corner of the map to capture an area for detection</p>
                </div>
                <div v-if="screenshotImage && !detectionResult" class="preview-panel">
                    <h3>Screenshot Preview</h3>
                    <div class="preview-image">
                        <img :src="screenshotImage" alt="Screenshot Preview" />
                    </div>
                    <div class="preview-actions">
                        <button class="action-btn detect" @click="detectObjects" :disabled="loading">
                            {{ loading ? 'Detecting...' : 'Detect Objects' }}
                        </button>
                        <button class="action-btn cancel" @click="clearScreenshot">Cancel</button>
                    </div>
                </div>
                <div v-if="loading" class="loading-overlay">
                    <div class="loading-spinner"></div>
                    <p>Processing image...</p>
                </div>
            </div>
            <div v-if="detectionResult" class="detection-results">
                <div class="result-header">
                    <h3>Detection Results</h3>
                    <button class="clear-btn" @click="clearResults">Clear</button>
                </div>
                <div class="result-content">
                    <div class="result-image" style="position:relative; width:100%;">
                        <img :src="originalImage" alt="Detection Result" ref="resultImg" @load="syncCanvas" style="width:100%; height:auto; display:block;"/>
                        <canvas ref="overlay" style="position:absolute; left:0; top:0; pointer-events:none;"></canvas>
                    </div>
                    <div class="result-stats">
                        <div class="stat-item">
                            <span class="stat-label">Objects Detected:</span>
                            <span class="stat-value">{{detectionResult.num_detections}}</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Confidence Threshold:</span>
                            <span class="stat-value">{{(detectionResult.conf_thres * 100).toFixed(1)}}%</span>
                        </div>
                    </div>
                    <div class="detections-list">
                        <h4>Detected Objects</h4>
                        <div class="detection-item" v-for="(det, index) in detectionResult.detections" :key="index">
                            <div class="detection-header">
                                <span class="detection-label">{{det.label}}</span>
                                <span class="detection-confidence">{{(det.confidence * 100).toFixed(1)}}%</span>
                            </div>
                            <div class="detection-bbox">
                                <span>Box: [{{det.bbox.map(x => x.toFixed(1)).join(', ')}}]</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `,
    data() {
        return {
            loading: false,
            detectionResult: null,
            screenshotImage: null,
            screenshotBlob: null,
            originalImage: null,
            objectUrl: null
        };
    },
    mounted() {
        console.log('YoloDetection mounted');
        // ÁõëÂê¨ÂÖ®Â±ÄÊà™Âõæ‰∫ã‰ª∂
        window.addEventListener('screenshot-taken', this.handleScreenshot);
        // ÁõëÂê¨Á™óÂè£Â§ßÂ∞èÂèòÂåñÔºåÈáçÊñ∞ÁªòÂà∂Ê£ÄÊµãÊ°Ü
        window.addEventListener('resize', this.handleResize);
        
        // ‰ΩøÁî®ResizeObserverÁõëÂê¨ÂõæÁâáÂÆπÂô®Â§ßÂ∞èÂèòÂåñÔºàÂåÖÊã¨Èù¢ÊùøË∞ÉÊï¥Ôºâ
        this.setupResizeObserver();
    },
    unmounted() {
        window.removeEventListener('screenshot-taken', this.handleScreenshot);
        window.removeEventListener('resize', this.handleResize);
        
        // Ê∏ÖÁêÜResizeObserver
        if (this.resizeObserver) {
            this.resizeObserver.disconnect();
            this.resizeObserver = null;
        }
        
        // Ê∏ÖÁêÜ blob URL
        if (this.objectUrl) {
            URL.revokeObjectURL(this.objectUrl);
            this.objectUrl = null;
        }
    },
    methods: {
        setupResizeObserver() {
            // Á≠âÂæÖ‰∏ã‰∏ÄÂ∏ßÁ°Æ‰øùDOMÂ∑≤Ê∏≤Êüì
            this.$nextTick(() => {
                const img = this.$refs.resultImg;
                if (img && window.ResizeObserver) {
                    // Ê∏ÖÁêÜÊóßÁöÑobserver
                    if (this.resizeObserver) {
                        this.resizeObserver.disconnect();
                    }
                    
                    // ÂàõÂª∫Êñ∞ÁöÑobserver
                    this.resizeObserver = new ResizeObserver(() => {
                        if (this.detectionResult) {
                            this.syncCanvas();
                        }
                    });
                    this.resizeObserver.observe(img);
                }
            });
        },
        handleResize() {
            // ÂΩìÁ™óÂè£Â§ßÂ∞èÂèòÂåñÊó∂ÔºåÈáçÊñ∞Ë∞ÉÊï¥canvasÂíåÈáçÁªòÊ£ÄÊµãÊ°Ü
            if (this.detectionResult) {
                this.$nextTick(() => this.syncCanvas());
            }
        },
        handleScreenshot(event) {
            console.log('Êî∂Âà∞Êà™Âõæ‰∫ã‰ª∂:', event.detail);
            // Ê∏ÖÁêÜÊóßÁöÑ blob URL
            if (this.objectUrl) {
                URL.revokeObjectURL(this.objectUrl);
            }
            
            // ‰øùÂ≠òÊñ∞ÁöÑ blob URL
            this.objectUrl = event.detail.imageUrl;
            this.screenshotImage = event.detail.imageUrl;
            this.screenshotBlob = event.detail.blob;
            this.originalImage = event.detail.imageUrl;
            this.detectionResult = null;
        },
        async detectObjects() {
            if (!this.screenshotBlob || !this.screenshotImage) return;
            
            try {
                this.loading = true;
                
                // ‰øùÂ≠òÂéüÂßãÂõæÂÉèÁî®‰∫éÊòæÁ§∫ÁªìÊûú
                this.originalImage = this.screenshotImage;
                
                // ÂàõÂª∫FormDataÂØπË±°
                const formData = new FormData();
                formData.append('file', this.screenshotBlob, 'screenshot.png');

                // ÂèëÈÄÅÂà∞ÂêéÁ´ØËøõË°åÊ£ÄÊµã
                const response = await fetch(`${API_BASE_URL}/api/yolo/predict`, {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error('Detection failed');
                }

                this.detectionResult = await response.json();
                
                // Ê∏ÖÈô§È¢ÑËßàÂõæÂÉèÔºà‰ΩÜ‰øùÁïô originalImage Áî®‰∫éÁªìÊûúÊòæÁ§∫Ôºâ
                this.screenshotImage = null;
                this.screenshotBlob = null;
                
                // Âú®‰∏ã‰∏ÄÂ∏ßÁªòÂà∂Ê£ÄÊµãÊ°ÜÂπ∂ËÆæÁΩÆResizeObserver
                this.$nextTick(() => {
                    this.syncCanvas();
                    this.setupResizeObserver();
                });
            } catch (error) {
                console.error('Detection failed:', error);
                alert('Detection failed: ' + error.message);
            } finally {
                this.loading = false;
            }
        },
        syncCanvas() {
            const img = this.$refs.resultImg;
            const canvas = this.$refs.overlay;
            if (!img || !canvas) return;
            
            const rect = img.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            
            this.drawDetections();
        },
        drawDetections() {
            const canvas = this.$refs.overlay;
            const img = this.$refs.resultImg;
            if (!canvas || !img || !this.detectionResult) {
                return;
            }
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const scaleX = canvas.width / img.naturalWidth;
            const scaleY = canvas.height / img.naturalHeight;

            for (const d of this.detectionResult.detections || []) {
                const [x1, y1, x2, y2] = d.bbox;
                const x = x1 * scaleX;
                const y = y1 * scaleY;
                const w = (x2 - x1) * scaleX;
                const h = (y2 - y1) * scaleY;
                
                // ÁªòÂà∂ËæπÁïåÊ°Ü
                ctx.strokeStyle = '#00ff00';  // ÁªøËâ≤
                ctx.lineWidth = 3;
                ctx.strokeRect(x, y, w, h);
                
                // ÁªòÂà∂Ê†áÁ≠æ
                const label = `${d.label} ${(d.confidence * 100).toFixed(1)}%`;
                ctx.font = 'bold 14px Arial';
                ctx.textBaseline = 'top';
                const textW = ctx.measureText(label).width + 8;
                const textH = 20;
                
                // Ê†áÁ≠æËÉåÊôØ
                ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
                ctx.fillRect(x, Math.max(0, y - textH - 2), textW, textH);
                
                // Ê†áÁ≠æÊñáÂ≠ó
                ctx.fillStyle = '#000';
                ctx.fillText(label, x + 4, Math.max(2, y - textH));
            }
        },
        clearScreenshot() {
            this.screenshotImage = null;
            this.screenshotBlob = null;
            this.originalImage = null;
            if (this.objectUrl) {
                URL.revokeObjectURL(this.objectUrl);
                this.objectUrl = null;
            }
            const canvas = this.$refs.overlay;
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx && ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        },
        clearResults() {
            this.detectionResult = null;
            this.originalImage = null;
            if (this.objectUrl) {
                URL.revokeObjectURL(this.objectUrl);
                this.objectUrl = null;
            }
            const canvas = this.$refs.overlay;
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx && ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        }
    }
};

// Á©∫Ë∑ØÁî±ÁªÑ‰ª∂ÔºàÁî®‰∫éÈªòËÆ§È°µÈù¢Ôºâ
const EmptyView = {
    template: '<div></div>'
};

// Ë∑ØÁî±ÈÖçÁΩÆ
const routes = [
    { 
        path: '/', 
        component: EmptyView,
        name: 'home'
    },
    { 
        path: '/route2', 
        component: TimeSeriesAnalysis,
        name: 'route2'
    },
    { 
        path: '/route3', 
        component: YoloDetection,
        name: 'route3'
    }
];

const router = VueRouter.createRouter({
    history: VueRouter.createWebHashHistory(),
    routes
});

// ÂàõÂª∫VueÂ∫îÁî®
const app = Vue.createApp({
    data() {
        return {
            currentRoute: '/',
            isScreenshotMode: false,
            screenshotRect: null,
            screenshotImage: null,
            screenshotBlob: null,
            timeseriesLoading: false,
            isPanelVisible: false,
            isPanelFixed: false,
            panelHideTimer: null
        };
    },
    watch: {
        $route(to) {
            this.currentRoute = to.path;
            // Â¶ÇÊûúÂàáÊç¢Âà∞È¶ñÈ°µÔºåËß£Èô§Âõ∫ÂÆöÁä∂ÊÄÅ
            if (to.path === '/') {
                this.isPanelFixed = false;
                this.isPanelVisible = false;
            }
            // Ê∏ÖÁêÜÊµãÈáèÂ∑•ÂÖ∑
            if (this.measureType) {
                this.measureType = null;
                this.removeMeasureInteraction();
            }
        }
    },
    mounted() {
        // Ê£ÄÊµãÈ°µÈù¢Âà∑Êñ∞ÔºåÂº∫Âà∂ÂõûÂà∞home
        const navEntries = performance.getEntriesByType('navigation');
        if (navEntries.length > 0 && navEntries[0].type === 'reload') {
            // È°µÈù¢Âà∑Êñ∞Êó∂ÔºåÈáçÂÆöÂêëÂà∞home
            this.$router.replace('/');
        }
        
        // ÂàùÂßãÂåñÂú∞Âõæ
        this.initMap();
        this.currentRoute = this.$route.path;
        this.initResizablePanel();
    },
    methods: {
        showPanel() {
            if (this.isPanelFixed) return;
            this.isPanelVisible = true;
            if (this.panelHideTimer) {
                clearTimeout(this.panelHideTimer);
                this.panelHideTimer = null;
            }
        },
        hidePanel() {
            if (this.isPanelFixed) return;
            this.panelHideTimer = setTimeout(() => {
                this.isPanelVisible = false;
            }, 300);
        },
        handlePanelMouseEnter() {
            if (this.panelHideTimer) {
                clearTimeout(this.panelHideTimer);
                this.panelHideTimer = null;
            }
        },
        handlePanelMouseLeave() {
            this.hidePanel();
        },
        activateRoute(path) {
            // Âõ∫ÂÆöÈù¢Êùø
            this.isPanelFixed = true;
            this.isPanelVisible = true;
            if (this.panelHideTimer) {
                clearTimeout(this.panelHideTimer);
                this.panelHideTimer = null;
            }
            
            // ÂàáÊç¢Ë∑ØÁî±
            this.$router.push(path);
            
            // Âª∂ËøüË∞ÉÊï¥Âú∞ÂõæÂ§ßÂ∞èÔºåÁ≠âÂæÖÈù¢ÊùøÂÆåÂÖ®ÊòæÁ§∫
            this.$nextTick(() => {
                setTimeout(() => {
                    if (window.map) {
                        window.map.updateSize();
                    }
                }, 300);
            });
        },
        closePanel() {
            // Ëß£Èô§Âõ∫ÂÆöÁä∂ÊÄÅ
            this.isPanelFixed = false;
            this.isPanelVisible = false;
            
            // ËøîÂõûÈ¶ñÈ°µ
            this.$router.push('/');
            
            // Â¶ÇÊûúÂú®Êà™ÂõæÊ®°ÂºèÔºåÈÄÄÂá∫Êà™ÂõæÊ®°Âºè
            if (this.isScreenshotMode) {
                this.startScreenshot(); // ÂàáÊç¢Áä∂ÊÄÅ‰ª•ÈÄÄÂá∫Êà™ÂõæÊ®°Âºè
            }
            
            // ÈáçÁΩÆÈù¢ÊùøÂíåÂú∞ÂõæÂÆπÂô®ÁöÑÂ∞∫ÂØ∏Ê†∑Âºè
            const mapContainer = document.querySelector('.map-container');
            const rightPanel = document.querySelector('.right-panel');
            
            if (mapContainer) {
                mapContainer.style.flex = '';  // Ê∏ÖÈô§ flex ËÆæÁΩÆÔºåÊÅ¢Â§çÈªòËÆ§
            }
            
            if (rightPanel) {
                rightPanel.style.width = '';  // Ê∏ÖÈô§ÂÆΩÂ∫¶ËÆæÁΩÆÔºåÊÅ¢Â§ç CSS ÈªòËÆ§ÂÄº (500px)
            }
            
            // Âª∂ËøüË∞ÉÊï¥Âú∞ÂõæÂ§ßÂ∞èÔºåÁ≠âÂæÖÈù¢ÊùøÂÆåÂÖ®ÈöêËóèÂíåÊ†∑ÂºèÈáçÁΩÆ
            this.$nextTick(() => {
                setTimeout(() => {
                    if (window.map) {
                        window.map.updateSize();
                    }
                }, 300);
            });
        },
        initResizablePanel() {
            const container = document.querySelector('.main-layout');
            const gutter = document.querySelector('.gutter');
            const mapContainer = document.querySelector('.map-container');
            const rightPanel = document.querySelector('.right-panel');

            let isResizing = false;

            if (gutter) {
            gutter.addEventListener('mousedown', (e) => {
                    if (!this.isPanelFixed) return;
                isResizing = true;
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', () => {
                    isResizing = false;
                    document.removeEventListener('mousemove', handleMouseMove);
                });
            });
            }

            const handleMouseMove = (e) => {
                if (!isResizing || !this.isPanelFixed) return;

                const containerRect = container.getBoundingClientRect();
                const percentage = ((e.clientX - containerRect.left) / containerRect.width) * 100;
                
                if (percentage < 20 || percentage > 80) return;

                mapContainer.style.flex = `0 0 ${percentage}%`;
                rightPanel.style.width = `${100 - percentage}%`;
                
                if (window.map) {
                    window.map.updateSize();
                }
                
                // Â¶ÇÊûúÂ≠òÂú®plotÂÆπÂô®‰∏îÊúâÊï∞ÊçÆÔºåÈáçÊñ∞Ë∞ÉÊï¥Â§ßÂ∞è
                const plotContainer = document.getElementById('plot-container');
                if (plotContainer && plotContainer.data) {
                    Plotly.Plots.resize(plotContainer);
                }
            }
        },
        initMap() {
            // ÂàõÂª∫ÂΩ±ÂÉèÂõæÂ±ÇÁªÑ
            const tianditu = new ol.layer.Tile({
                title: 'Â§©Âú∞ÂõæÂΩ±ÂÉè',
                type: 'base',
                visible: false,
                source: new ol.source.XYZ({
                    url: 'https://t{0-7}.tianditu.gov.cn/img_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=img&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TileMatrix={z}&TileCol={x}&TileRow={y}&tk=76272abff72b48bbe6768915c647f48b',
                crossOrigin: 'anonymous'
                })
            });

            const googleSat = new ol.layer.Tile({
                title: 'Google Âç´Êòü',
                type: 'base',
                visible: false,
                source: new ol.source.XYZ({
                    url: 'https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',
                    crossOrigin: 'anonymous'
                })
            });

            const esriImagery = new ol.layer.Tile({
                title: 'ESRI ÂΩ±ÂÉè',
                type: 'base',
                visible: true,
                source: new ol.source.XYZ({
                    url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                    crossOrigin: 'anonymous'
                })
            });

            // ÂàõÂª∫ RTS ÂõæÂ±Ç
            let predictedRTSLayer = null;
            let xiadataRTSLayer = null;

            if (typeof json_PredictedRTS !== 'undefined' && json_PredictedRTS.features && json_PredictedRTS.features.length > 0) {
                const predictedSource = new ol.source.Vector({
                    features: new ol.format.GeoJSON().readFeatures(json_PredictedRTS, {
                        featureProjection: 'EPSG:3857'
                    })
                });

                predictedRTSLayer = new ol.layer.Vector({
                    title: 'Predicted RTS',
                    source: predictedSource,
                    style: new ol.style.Style({
                        stroke: new ol.style.Stroke({
                            color: 'rgba(229,90,35,1.0)',
                            width: 2
                        }),
                        fill: new ol.style.Fill({
                            color: 'rgba(196,60,57,0.3)'
                        })
                    }),
                    visible: true
                });
            }

            if (typeof json_XiadataRTS !== 'undefined' && json_XiadataRTS.features && json_XiadataRTS.features.length > 0) {
                const xiadataSource = new ol.source.Vector({
                    features: new ol.format.GeoJSON().readFeatures(json_XiadataRTS, {
                        featureProjection: 'EPSG:3857'
                    })
                });

                xiadataRTSLayer = new ol.layer.Vector({
                    title: 'Xia RTS 2022',
                    source: xiadataSource,
                    style: new ol.style.Style({
                        stroke: new ol.style.Stroke({
                            color: 'rgba(205,186,35,1.0)',
                            width: 2
                        }),
                        fill: new ol.style.Fill({
                            color: 'rgba(225,89,137,0.3)'
                        })
                    }),
                    visible: true
                });
            }

            // ÂàõÂª∫ÂõæÂ±ÇÊï∞ÁªÑ
            const layers = [tianditu, googleSat, esriImagery];
            if (xiadataRTSLayer) layers.push(xiadataRTSLayer);
            if (predictedRTSLayer) layers.push(predictedRTSLayer);

            // ÂàõÂª∫Âú∞Âõæ
            window.map = new ol.Map({
                target: 'map',
                layers: layers,
                view: new ol.View({
                    center: ol.proj.fromLonLat([92.74256077, 35.06289152]),
                    zoom: 16,
                    maxZoom: 21,
                    minZoom: 1
                })
            });

            // Ê∑ªÂä†ÂõæÂ±ÇÂàáÊç¢Êéß‰ª∂ÔºàÂè≥‰∏ãËßíÔºåÂèØÊäòÂè†Ôºâ
            const layerSwitcherContainer = document.createElement('div');
            layerSwitcherContainer.className = 'ol-layer-switcher-container';
            layerSwitcherContainer.style.cssText = 'position: absolute; bottom: 30px; left: 10px; z-index: 1000;';
            
            // ÊäòÂè†/Â±ïÂºÄÊåâÈíÆ
            const toggleButton = document.createElement('button');
            toggleButton.className = 'layer-switcher-toggle';
            toggleButton.innerHTML = '<i class="fas fa-layer-group"></i>';
            toggleButton.title = 'Layer Control';
            toggleButton.style.cssText = 'background: rgba(255,255,255,0.9); border: none; width: 40px; height: 40px; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.2); cursor: pointer; font-size: 16px; color: #333; display: flex; align-items: center; justify-content: center; transition: all 0.3s;';
            
            // ÂõæÂ±ÇÈù¢Êùø
            const layerSwitcher = document.createElement('div');
            layerSwitcher.className = 'ol-layer-switcher-panel';
            layerSwitcher.style.cssText = 'background: rgba(255,255,255,0.95); padding: 12px; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.3); max-height: 400px; overflow-y: auto; margin-bottom: 8px; display: none; min-width: 200px; position: absolute; bottom: 48px; left: 0;';
            
            // Ê†áÈ¢òÊ†è
            const layerHeader = document.createElement('div');
            layerHeader.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid #ddd;';
            
            const layerTitle = document.createElement('div');
            layerTitle.textContent = 'Layer Control';
            layerTitle.style.cssText = 'font-weight: bold; font-size: 14px; color: #333;';
            
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = '√ó';
            closeBtn.style.cssText = 'background: none; border: none; font-size: 20px; cursor: pointer; color: #666; padding: 0; width: 20px; height: 20px; line-height: 1;';
            closeBtn.title = 'Close';
            
            layerHeader.appendChild(layerTitle);
            layerHeader.appendChild(closeBtn);
            layerSwitcher.appendChild(layerHeader);

            // Â∫ïÂõæÈÄâÊã©
            const baseLayerDiv = document.createElement('div');
            baseLayerDiv.style.marginBottom = '12px';
            
            const baseTitle = document.createElement('div');
            baseTitle.textContent = 'Base Maps:';
            baseTitle.style.cssText = 'font-size: 12px; color: #666; margin-bottom: 6px; font-weight: 600;';
            baseLayerDiv.appendChild(baseTitle);
            
            const baseLayerNames = {
                'Â§©Âú∞ÂõæÂΩ±ÂÉè': 'Tianditu',
                'Google Âç´Êòü': 'Google Satellite',
                'ESRI ÂΩ±ÂÉè': 'ESRI Imagery'
            };
            
            [tianditu, googleSat, esriImagery].forEach(layer => {
                const label = document.createElement('label');
                label.style.cssText = 'display: flex; align-items: center; font-size: 12px; margin: 4px 0; cursor: pointer; padding: 2px 0;';
                const input = document.createElement('input');
                input.type = 'radio';
                input.name = 'baselayer';
                input.checked = layer.getVisible();
                input.style.cssText = 'margin-right: 6px;';
                input.addEventListener('change', () => {
                    [tianditu, googleSat, esriImagery].forEach(l => l.setVisible(false));
                    layer.setVisible(true);
                });
                label.appendChild(input);
                const layerName = baseLayerNames[layer.get('title')] || layer.get('title');
                label.appendChild(document.createTextNode(layerName));
                baseLayerDiv.appendChild(label);
            });
            layerSwitcher.appendChild(baseLayerDiv);

            // Êï∞ÊçÆÂõæÂ±ÇÈÄâÊã©
            if (predictedRTSLayer || xiadataRTSLayer) {
                const dataLayerDiv = document.createElement('div');
                
                const dataTitle = document.createElement('div');
                dataTitle.textContent = 'Data Layers:';
                dataTitle.style.cssText = 'font-size: 12px; color: #666; margin-bottom: 6px; font-weight: 600;';
                dataLayerDiv.appendChild(dataTitle);
                
                [predictedRTSLayer, xiadataRTSLayer].filter(l => l).forEach(layer => {
                    const label = document.createElement('label');
                    label.style.cssText = 'display: flex; align-items: center; font-size: 12px; margin: 4px 0; cursor: pointer; padding: 2px 0;';
                    const input = document.createElement('input');
                    input.type = 'checkbox';
                    input.checked = layer.getVisible();
                    input.style.cssText = 'margin-right: 6px;';
                    input.addEventListener('change', (e) => {
                        layer.setVisible(e.target.checked);
                    });
                    label.appendChild(input);
                    label.appendChild(document.createTextNode(layer.get('title')));
                    dataLayerDiv.appendChild(label);
                });
                layerSwitcher.appendChild(dataLayerDiv);
            }

            // ÂàáÊç¢ÊòæÁ§∫/ÈöêËóè
            let isExpanded = false;
            toggleButton.addEventListener('click', () => {
                isExpanded = !isExpanded;
                layerSwitcher.style.display = isExpanded ? 'block' : 'none';
                toggleButton.style.background = isExpanded ? 'rgba(76, 175, 80, 0.9)' : 'rgba(255,255,255,0.9)';
                toggleButton.style.color = isExpanded ? '#fff' : '#333';
            });
            
            closeBtn.addEventListener('click', () => {
                isExpanded = false;
                layerSwitcher.style.display = 'none';
                toggleButton.style.background = 'rgba(255,255,255,0.9)';
                toggleButton.style.color = '#333';
            });

            layerSwitcherContainer.appendChild(layerSwitcher);
            layerSwitcherContainer.appendChild(toggleButton);
            document.getElementById('map').appendChild(layerSwitcherContainer);

            // ‰øùÂ≠òÂõæÂ±ÇÂºïÁî®
            window.mapLayers = {
                predicted: predictedRTSLayer,
                xiadata: xiadataRTSLayer
            };
        },
        startScreenshot() {
            this.isScreenshotMode = !this.isScreenshotMode;
            
            if (this.isScreenshotMode) {
                // ÂêØÁî®Êà™ÂõæÊ®°Âºè - OpenLayers
                const mapElement = window.map.getTargetElement();
                mapElement.style.cursor = 'crosshair';
                mapElement.addEventListener('mousedown', this.onMapMouseDown);
                
                // Á¶ÅÁî®Âú∞Âõæ‰∫§‰∫íÔºàÊãñÊãΩ„ÄÅÁº©ÊîæÁ≠âÔºâ
                window.map.getInteractions().forEach(interaction => {
                    if (interaction instanceof ol.interaction.DragPan || 
                        interaction instanceof ol.interaction.MouseWheelZoom ||
                        interaction instanceof ol.interaction.DoubleClickZoom ||
                        interaction instanceof ol.interaction.DragZoom) {
                        interaction._wasActive = interaction.getActive();
                        interaction.setActive(false);
                    }
                });
                
                // ÈöêËóè RTS ÂõæÂ±Ç
                if (window.mapLayers) {
                    if (window.mapLayers.predicted) {
                        window.mapLayers.predicted._visibleBeforeScreenshot = window.mapLayers.predicted.getVisible();
                        window.mapLayers.predicted.setVisible(false);
                    }
                    if (window.mapLayers.xiadata) {
                        window.mapLayers.xiadata._visibleBeforeScreenshot = window.mapLayers.xiadata.getVisible();
                        window.mapLayers.xiadata.setVisible(false);
                    }
                }
            } else {
                // Á¶ÅÁî®Êà™ÂõæÊ®°Âºè
                const mapElement = window.map.getTargetElement();
                mapElement.style.cursor = '';
                mapElement.removeEventListener('mousedown', this.onMapMouseDown);
                if (this.screenshotOverlay) {
                    window.map.removeOverlay(this.screenshotOverlay);
                    this.screenshotOverlay = null;
                }
                
                // ÊÅ¢Â§çÂú∞Âõæ‰∫§‰∫íÂíåÂõæÂ±Ç
                this.restoreMapInteractions();
            }
        },
        restoreMapInteractions() {
            // ÊÅ¢Â§çÂú∞Âõæ‰∫§‰∫í
            window.map.getInteractions().forEach(interaction => {
                if (interaction._wasActive !== undefined) {
                    interaction.setActive(interaction._wasActive);
                    delete interaction._wasActive;
                }
            });
            
            // ÊÅ¢Â§ç RTS ÂõæÂ±ÇÁöÑÂèØËßÅÊÄß
            if (window.mapLayers) {
                if (window.mapLayers.predicted && window.mapLayers.predicted._visibleBeforeScreenshot !== undefined) {
                    window.mapLayers.predicted.setVisible(window.mapLayers.predicted._visibleBeforeScreenshot);
                    delete window.mapLayers.predicted._visibleBeforeScreenshot;
                }
                if (window.mapLayers.xiadata && window.mapLayers.xiadata._visibleBeforeScreenshot !== undefined) {
                    window.mapLayers.xiadata.setVisible(window.mapLayers.xiadata._visibleBeforeScreenshot);
                    delete window.mapLayers.xiadata._visibleBeforeScreenshot;
                }
            }
        },
        onMapMouseDown(e) {
            const app = this;
            if (!app.$data.isScreenshotMode) return;

            e.preventDefault();
            e.stopPropagation();
            
            const mapElement = window.map.getTargetElement();
            const rect = mapElement.getBoundingClientRect();
            
            // Ëé∑ÂèñÁõ∏ÂØπ‰∫éÂú∞ÂõæÂÆπÂô®ÁöÑÂùêÊ†á
            const getRelativeCoords = (event) => {
                const mapRect = mapElement.getBoundingClientRect();
                return {
                    x: event.clientX - mapRect.left,
                    y: event.clientY - mapRect.top
                };
            };
            
            const startCoords = getRelativeCoords(e);
            const startPixel = [startCoords.x, startCoords.y];
            let overlayElement = null;

            const onMouseMove = (moveEvent) => {
                if (overlayElement) {
                    overlayElement.remove();
                }

                const endCoords = getRelativeCoords(moveEvent);
                const endPixel = [endCoords.x, endCoords.y];
                const minX = Math.min(startPixel[0], endPixel[0]);
                const minY = Math.min(startPixel[1], endPixel[1]);
                const maxX = Math.max(startPixel[0], endPixel[0]);
                const maxY = Math.max(startPixel[1], endPixel[1]);

                overlayElement = document.createElement('div');
                overlayElement.style.cssText = `
                    position: absolute;
                    left: ${minX}px;
                    top: ${minY}px;
                    width: ${maxX - minX}px;
                    height: ${maxY - minY}px;
                    border: 2px solid #0088ff;
                    background: rgba(0, 136, 255, 0.1);
                    pointer-events: none;
                    z-index: 1000;
                `;
                mapElement.appendChild(overlayElement);
            };

            const onMouseUp = async (upEvent) => {
                mapElement.removeEventListener('mousemove', onMouseMove);
                mapElement.removeEventListener('mouseup', onMouseUp);
                mapElement.style.cursor = 'crosshair';
                
                if (overlayElement) {
                    const endCoords = getRelativeCoords(upEvent);
                    const endPixel = [endCoords.x, endCoords.y];
                    const minX = Math.min(startPixel[0], endPixel[0]);
                    const minY = Math.min(startPixel[1], endPixel[1]);
                    const maxX = Math.max(startPixel[0], endPixel[0]);
                    const maxY = Math.max(startPixel[1], endPixel[1]);

                    overlayElement.remove();
                    await app.captureAndDetect({ minX, minY, maxX, maxY });
                }
                
                // Êà™ÂõæÂÆåÊàêÂêéÔºåËá™Âä®ÈÄÄÂá∫Êà™ÂõæÊ®°Âºè
                app.$data.isScreenshotMode = false;
                
                // ÊÅ¢Â§çÂú∞Âõæ‰∫§‰∫íÂäüËÉΩ
                app.restoreMapInteractions();
            };

            mapElement.addEventListener('mousemove', onMouseMove);
            mapElement.addEventListener('mouseup', onMouseUp);
        },
        async captureAndDetect(bounds) {
            try {
                console.log('ÂºÄÂßãÊà™Âõæ...');

                const mapEl = document.querySelector('#map');

                // ÂÖàÊà™ÂèñÊï¥‰∏™Âú∞ÂõæÔºàÂêØÁî®CORS‰ª•ÈÅøÂÖçÊ±°ÊüìÁîªÂ∏ÉÔºâ
                const fullCanvas = await html2canvas(mapEl, {
                    useCORS: true,
                    allowTaint: false,
                    logging: false,
                    backgroundColor: null
                });

                // ‰ΩøÁî®ÂÉèÁ¥†ËåÉÂõ¥Ë£ÅÂâ™
                const x = bounds.minX;
                const y = bounds.minY;
                const w = bounds.maxX - bounds.minX;
                const h = bounds.maxY - bounds.minY;

                if (w < 10 || h < 10) {
                    alert('Selected area is too small. Please select a larger area for detection.');
                    return;
                }

                // Â§ÑÁêÜ DPR Áº©ÊîæÔºàhtml2canvas ÂèØËÉΩÊåâ devicePixelRatio ÊîæÂ§ßÔºâ
                const scaleX = fullCanvas.width / mapEl.clientWidth;
                const scaleY = fullCanvas.height / mapEl.clientHeight;

                const sx = Math.round(x * scaleX);
                const sy = Math.round(y * scaleY);
                const swidth = Math.round(w * scaleX);
                const sheight = Math.round(h * scaleY);

                // Á°Æ‰øùÁº©ÊîæÂêéÁöÑÂ∞∫ÂØ∏ÊúâÊïàÔºàËá≥Â∞ë10x10ÂÉèÁ¥†Ôºâ
                if (swidth < 10 || sheight < 10) {
                    alert('Selected area is too small after scaling. Please select a larger area for detection.');
                    return;
                }

                // Ë£ÅÂâ™Âà∞ÊâÄÈÄâÂå∫Âüü
                const cropped = document.createElement('canvas');
                cropped.width = swidth;
                cropped.height = sheight;
                const ctx = cropped.getContext('2d');
                ctx.drawImage(fullCanvas, sx, sy, swidth, sheight, 0, 0, swidth, sheight);

                // ÁîüÊàê Blob
                const blob = await new Promise((resolve, reject) => {
                    cropped.toBlob(b => b ? resolve(b) : reject(new Error('toBlob failed')), 'image/png');
                });

                // È¢ÑËßà URL
                const imageUrl = URL.createObjectURL(blob);

                // ÂàÜÂèëÊà™Âõæ‰∫ã‰ª∂
                const event = new CustomEvent('screenshot-taken', {
                    detail: { imageUrl, blob }
                });
                window.dispatchEvent(event);

            } catch (error) {
                console.error('Screenshot failed:', error);
                alert('Screenshot failed: ' + error.message);
            }
        }
    }
});

// Ê∑ªÂä†ÊµãÈáèÂäüËÉΩÂíå‰ΩçÁΩÆÊêúÁ¥¢ÂäüËÉΩ
const measureApp = {
    data() {
        return {
            isPanelFixed: false,
            isPanelVisible: false,
            isScreenshotMode: false,
            timeseriesLoading: false,
            panelHideTimer: null,
            screenshotOverlay: null,
            measureType: null,  // 'distance' Êàñ 'area' Êàñ null
            measureDraw: null,  // ÁªòÂõæ‰∫§‰∫í
            measureTooltipElement: null,
            measureTooltip: null,
            measureSketch: null,
            measureLayer: null,
            searchCoordinates: '',  // ÊêúÁ¥¢ÂùêÊ†áËæìÂÖ•
            searchBoxMinimized: false,  // ÊêúÁ¥¢Ê°ÜÊòØÂê¶ÊúÄÂ∞èÂåñ
            locationMarker: null,  // ‰ΩçÁΩÆÊ†áËÆ∞
        }
    },
    methods: {
        // ÂàõÂª∫ÊµãÈáèÊèêÁ§∫Ê°Ü
        createMeasureTooltip() {
            if (this.measureTooltipElement) {
                this.measureTooltipElement.parentNode.removeChild(this.measureTooltipElement);
            }
            this.measureTooltipElement = document.createElement('div');
            this.measureTooltipElement.className = 'ol-tooltip ol-tooltip-measure';
            this.measureTooltip = new ol.Overlay({
                element: this.measureTooltipElement,
                offset: [0, -15],
                positioning: 'bottom-center',
                stopEvent: false,
                insertFirst: false,
            });
            window.map.addOverlay(this.measureTooltip);
        },

        // Ê†ºÂºèÂåñÈïøÂ∫¶
        formatLength(line) {
            const length = ol.sphere.getLength(line);
            let output;
            if (length > 1000) {
                output = (Math.round(length / 1000 * 100) / 100) + ' km';
            } else {
                output = (Math.round(length * 100) / 100) + ' m';
            }
            return output;
        },

        // Ê†ºÂºèÂåñÈù¢ÁßØ
        formatArea(polygon) {
            const area = ol.sphere.getArea(polygon);
            let output;
            if (area > 1000000) {
                output = (Math.round(area / 1000000 * 100) / 100) + ' km¬≤';
            } else {
                output = (Math.round(area * 100) / 100) + ' m¬≤';
            }
            return output;
        },

        // ÂàáÊç¢ÊµãÈáèÂ∑•ÂÖ∑
        toggleMeasure(type) {
            // Â¶ÇÊûúÁÇπÂáªÂΩìÂâçÊøÄÊ¥ªÁöÑÂ∑•ÂÖ∑ÔºåÂàôÂÖ≥Èó≠ÂÆÉ
            if (this.measureType === type) {
                this.measureType = null;
                this.removeMeasureInteraction();
                // Ê∏ÖÈô§ÊâÄÊúâÊµãÈáèÂõæÂΩ¢
                if (this.measureLayer) {
                    this.measureLayer.getSource().clear();
                }
                return;
            }

            this.measureType = type;
            this.removeMeasureInteraction();
            
            // Ê∏ÖÈô§‰πãÂâçÁöÑÊµãÈáèÂõæÂΩ¢
            if (this.measureLayer) {
                this.measureLayer.getSource().clear();
            }

            // ÂàõÂª∫ÁªòÂõæÂõæÂ±ÇÔºàÂ¶ÇÊûú‰∏çÂ≠òÂú®Ôºâ
            if (!this.measureLayer) {
                this.measureLayer = new ol.layer.Vector({
                    source: new ol.source.Vector(),
                    style: new ol.style.Style({
                        fill: new ol.style.Fill({
                            color: 'rgba(255, 255, 255, 0.4)',
                        }),
                        stroke: new ol.style.Stroke({
                            color: '#1976d2',
                            width: 2,
                        }),
                        image: new ol.style.Circle({
                            radius: 4,
                            stroke: new ol.style.Stroke({
                                color: '#1976d2',
                                width: 2,
                            }),
                            fill: new ol.style.Fill({
                                color: '#fff',
                            }),
                        }),
                    }),
                });
                window.map.addLayer(this.measureLayer);
            }

            // ÂàõÂª∫ÁªòÂõæ‰∫§‰∫í
            this.measureDraw = new ol.interaction.Draw({
                source: this.measureLayer.getSource(),
                type: type === 'area' ? 'Polygon' : 'LineString',
                    style: new ol.style.Style({
                    fill: new ol.style.Fill({
                        color: 'rgba(255, 255, 255, 0.4)',
                    }),
                    stroke: new ol.style.Stroke({
                        color: '#1976d2',
                        lineDash: [6, 6],
                        width: 2,
                    }),
                    image: new ol.style.Circle({
                        radius: 4,
                        stroke: new ol.style.Stroke({
                            color: '#1976d2',
                            width: 2,
                        }),
                        fill: new ol.style.Fill({
                            color: '#fff',
                        }),
                    }),
                }),
            });

            // ÂàõÂª∫ÊµãÈáèÊèêÁ§∫
            this.createMeasureTooltip();

            // Ê∑ªÂä†ÁªòÂõæ‰∫ã‰ª∂ÁõëÂê¨Âô®
            this.measureDraw.on('drawstart', (evt) => {
                this.measureSketch = evt.feature;

                let tooltipCoord = evt.coordinate;

                this.measureSketch.getGeometry().on('change', (evt) => {
                    const geom = evt.target;
                    let output;
                    if (geom instanceof ol.geom.Polygon) {
                        output = this.formatArea(geom);
                        tooltipCoord = geom.getInteriorPoint().getCoordinates();
                    } else if (geom instanceof ol.geom.LineString) {
                        output = this.formatLength(geom);
                        tooltipCoord = geom.getLastCoordinate();
                    }
                    this.measureTooltipElement.innerHTML = output;
                    this.measureTooltip.setPosition(tooltipCoord);
                });
            });

            this.measureDraw.on('drawend', () => {
                this.measureTooltipElement.className = 'ol-tooltip ol-tooltip-static';
                this.measureTooltip.setOffset([0, -7]);
                this.measureSketch = null;
                this.createMeasureTooltip();
            });

            window.map.addInteraction(this.measureDraw);
        },

        // ÁßªÈô§ÊµãÈáè‰∫§‰∫í
        removeMeasureInteraction() {
            if (this.measureDraw) {
                window.map.removeInteraction(this.measureDraw);
                this.measureDraw = null;
            }
            if (this.measureTooltipElement) {
                this.measureTooltipElement.parentNode.removeChild(this.measureTooltipElement);
                this.measureTooltipElement = null;
            }
            if (this.measureTooltip) {
                window.map.removeOverlay(this.measureTooltip);
                this.measureTooltip = null;
            }
        },

        // ‰ΩçÁΩÆÊêúÁ¥¢ÂäüËÉΩ
        searchLocation() {
            const coords = this.searchCoordinates.trim();
            let lon, lat;
            
            // Â¶ÇÊûúÊ≤°ÊúâËæìÂÖ•Ôºå‰ΩøÁî®ÈªòËÆ§ÂùêÊ†á
            if (!coords) {
                lon = 92.74585837;
                lat = 35.07621963;
            } else {
                // Ëß£ÊûêÂùêÊ†á (ÊîØÊåÅÂ§öÁßçÊ†ºÂºè)
                const parts = coords.split(/[,\s]+/).filter(p => p);
                if (parts.length !== 2) {
                    alert('Invalid format. Please use: longitude, latitude');
                    return;
                }

                lon = parseFloat(parts[0]);
                lat = parseFloat(parts[1]);
            }

            if (isNaN(lon) || isNaN(lat)) {
                alert('Invalid coordinates. Please enter valid numbers');
                return;
            }

            if (lon < -180 || lon > 180 || lat < -90 || lat > 90) {
                alert('Coordinates out of range. Longitude: -180 to 180, Latitude: -90 to 90');
                return;
            }

            // ËΩ¨Êç¢ÂùêÊ†áÂπ∂ÂÆö‰Ωç
            const coordinate = ol.proj.fromLonLat([lon, lat]);
            
            // ÁßªÂä®Âú∞ÂõæÂà∞ÁõÆÊ†á‰ΩçÁΩÆ
            window.map.getView().animate({
                center: coordinate,
                zoom: 16,
                duration: 1000
            });

            // ÂàõÂª∫È´ò‰∫ÆÊ†áËÆ∞
            this.createLocationMarker(coordinate);
        },

        // ÂàõÂª∫‰ΩçÁΩÆÊ†áËÆ∞
        createLocationMarker(coordinate) {
            // ÁßªÈô§ÊóßÊ†áËÆ∞
            if (this.locationMarker) {
                window.map.removeOverlay(this.locationMarker);
            }

            // ÂàõÂª∫Ê†áËÆ∞ÂÖÉÁ¥†
            const markerElement = document.createElement('div');
            markerElement.style.cssText = `
                width: 20px;
                height: 20px;
                background: #ff4444;
                border: 3px solid white;
                border-radius: 50%;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
                animation: location-pulse 1s ease-in-out infinite;
            `;

            // ÂàõÂª∫ Overlay
            this.locationMarker = new ol.Overlay({
                element: markerElement,
                positioning: 'center-center',
                stopEvent: false,
            });

            this.locationMarker.setPosition(coordinate);
            window.map.addOverlay(this.locationMarker);

            // 3ÁßíÂêéÁßªÈô§Ê†áËÆ∞
            setTimeout(() => {
                if (this.locationMarker) {
                    window.map.removeOverlay(this.locationMarker);
                    this.locationMarker = null;
                }
            }, 3000);
        },

        // ÂàáÊç¢ÊêúÁ¥¢Ê°ÜÊúÄÂ∞èÂåñÁä∂ÊÄÅ
        toggleSearchBox() {
            this.searchBoxMinimized = !this.searchBoxMinimized;
        },

        // ÂàùÂßãÂåñÊêúÁ¥¢Ê°ÜÊãñÂä®ÂäüËÉΩ
        initSearchBoxDrag() {
            const searchBox = document.getElementById('locationSearchBox');
            const mapContainer = document.querySelector('.map-container');
            
            if (!searchBox || !mapContainer) return;

            let isDragging = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;
            let xOffset = 0;
            let yOffset = 0;

            // ÈôêÂà∂‰ΩçÁΩÆÂú®Âú∞ÂõæÂÆπÂô®ÂÜÖ
            const constrainPosition = () => {
                const mapRect = mapContainer.getBoundingClientRect();
                const boxRect = searchBox.getBoundingClientRect();
                
                // ËÆ°ÁÆóÁõ∏ÂØπ‰∫éÂú∞ÂõæÂÆπÂô®ÁöÑËæπÁïå
                const minX = 10;
                const maxX = mapRect.width - boxRect.width - 10;
                const minY = 10;
                const maxY = mapRect.height - boxRect.height - 10;
                
                // ÈôêÂà∂ X ÂùêÊ†á
                if (xOffset < minX) xOffset = minX;
                if (xOffset > maxX) xOffset = maxX;
                
                // ÈôêÂà∂ Y ÂùêÊ†á
                if (yOffset < minY) yOffset = minY;
                if (yOffset > maxY) yOffset = maxY;
                
                searchBox.style.left = `${xOffset}px`;
                searchBox.style.top = `${yOffset}px`;
            };

            // Ëé∑ÂèñÂàùÂßã‰ΩçÁΩÆ
            const getInitialOffset = () => {
                const computedStyle = window.getComputedStyle(searchBox);
                xOffset = parseInt(computedStyle.left) || 60;
                yOffset = parseInt(computedStyle.top) || 10;
            };

            searchBox.addEventListener('mousedown', (e) => {
                // Â¶ÇÊûúÁÇπÂáªÁöÑÊòØËæìÂÖ•Ê°ÜÊàñÊåâÈíÆÔºå‰∏çËß¶ÂèëÊãñÂä®
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON' || e.target.tagName === 'I') {
                    return;
                }
                
                // Â¶ÇÊûúÊòØÈ¶ñÊ¨°ÊãñÂä®ÔºåËé∑ÂèñÂàùÂßã‰ΩçÁΩÆ
                if (xOffset === 0 && yOffset === 0) {
                    getInitialOffset();
                }
                
                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;
                isDragging = true;
                searchBox.style.cursor = 'grabbing';
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    xOffset = currentX;
                    yOffset = currentY;

                    constrainPosition();
                }
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    searchBox.style.cursor = 'move';
                }
            });

            // ËÆæÁΩÆÂàùÂßãÂÖâÊ†áÊ†∑Âºè
            searchBox.style.cursor = 'move';

            // ÁõëÂê¨Á™óÂè£Â§ßÂ∞èÂèòÂåñÔºåÁ°Æ‰øùÊêúÁ¥¢Ê°ÜÂßãÁªàÂú®ÂèØËßÅÂå∫ÂüüÂÜÖ
            window.addEventListener('resize', () => {
                // Ëé∑ÂèñÂΩìÂâç‰ΩçÁΩÆÔºàÂ¶ÇÊûúËøòÊ≤°ÊúâÊãñÂä®ËøáÔºâ
                if (xOffset === 0 && yOffset === 0) {
                    getInitialOffset();
                }
                constrainPosition();
            });
        },
    },
    watch: {
        measureType(newVal) {
            if (!newVal) {
                this.removeMeasureInteraction();
            }
        }
    },
    mounted() {
        // ÂàùÂßãÂåñÊêúÁ¥¢Ê°ÜÊãñÂä®ÂäüËÉΩ
        this.$nextTick(() => {
            this.initSearchBoxDrag();
        });
    }
};

// ÂêàÂπ∂ÊµãÈáèÂäüËÉΩÂà∞‰∏ªÂ∫îÁî®
Object.assign(app._component.data(), measureApp.data());
Object.assign(app._component.methods, measureApp.methods);
if (!app._component.watch) app._component.watch = {};
Object.assign(app._component.watch, measureApp.watch);

// ÂêàÂπ∂ mounted Èí©Â≠ê
const originalMounted = app._component.mounted;
if (measureApp.mounted) {
    app._component.mounted = function() {
        if (originalMounted) originalMounted.call(this);
        measureApp.mounted.call(this);
    };
}

app.use(router);
app.mount('#app');
